var chalk = require('chalk');//for coloring console ouput
var mongoose = require( 'mongoose' );//for creating schema and models
var bcrypt=require('bcrypt');//for encrytpting 
var SALT_WORK_FACTOR = 10;//another input into hashing algorithm, we consider as a key& salt, 
//but to make the salt itslef really strong, there are iteration in which randomness generated
//so you can create highly random nubmer by using SALT_WORK_FACTOR, higher the number slower the
//algorithm into work, typically in the industry we use 1000 to 10,000. that is the number of iteration
//used, but for demo we are using only 10, 

//var dbURI = 'mongodb://localhost/test'; 

//local// var dbURI = 'mongodb://localhost/RajDB';  //slide 33 connecting to default port and database name test, 
//Mlab//  var dbURI = 'mongodb://Rajiv:RajivDB1@ds061360.mlab.com:61360/rajivmongodb-v1';
var dbURI = 'mongodb://Rajiv:RajivDB1@ds061360.mlab.com:61360/rajivmongodb-v1';

//if test database does not exist then it will create and start using the database.  
//var dbURI = 'mongodb://localhost:27107/test';  //same as above but showing the port number
//mongodb is running on localhost on the default port 

//mongo://ds061360.mlab.com: Port: 61360 Database Naem: rajivmongodb-v1 -username:Rajiv -password:RajivDB1 

//https://mystory88.herokuapp.com/stories


mongoose.connect(dbURI);//connect to database with pkg.mongoose

//slide 34 below we can check the status of our connection using .connection object which is created 
//automatically when we usng .connet method above. we can use .connection to register our callback
//function, .on is a listener, on event known as connected which is internally generated by mongooes
//mongooes generates on successful connection and event knows as connected, so we are listening for an event
//on mongooes connection which is called as connected, in the callback function all we will do is console.log
//instead of directly give a string and using chalk.yellow which string can covert into yellow color 
mongoose.connection.on('connected', function () {
  console.log(chalk.yellow('Mongoose connected to ' + dbURI));
});

mongoose.connection.on('error',function (err) {
  console.log(chalk.red('Mongoose connection error: ' + err));
});

mongoose.connection.on('disconnected', function () {
  console.log(chalk.red('Mongoose disconnected'));
});

//slide 35 created the schema, using mongoose we will create schema for our database collection known as userSchema,
//first we will create schema than model and then use the model, for queries on top of the model and you can use
//model instances which is next step forward after model. So   
var userSchema = new mongoose.Schema({  //return new schema obj call userSchema
  //coming up with field name and sort of validation on top of it and some constrain 
  //field names username, email, password and its type and constrain are unique to true
  username: {type: String, unique:true},//field name, type of name, constrain to unique:true
  email: {type: String, unique:true},//use obj.notation { } when you have constrain input
  password: String //using key and value pair for password, no use of constrain
});//so now we have userSchema object 

//certain things known as hooks, in this case we are taking help of hook, also helper funciton which is written
//on top of methods() below. Whenever we create schema, we will also specify helper methods and some hook and then we will 
//finally I am able to build/create model as we did below, 
//hook's are nothing but a function which are registered as callback function. simple pre.save hood for encrypting password 
userSchema.pre('save', //defining pre.save hook on top of our userSchem, before storing into database do below 

//callback function start and cascade of more call back func inside in inside 
function(next) //use our call back function always has parameter (next), so this is a function which you call
{ //when you want to exit from the call back function, another call back function which is passed into another call back function          
    var user = this;//calling userSchema(model), points to model instance or document which we need to modify
    console.log("Before Registering the user");
    // only hash the password if it has been modified (or is new)
    if (!user.isModified('password')) return next();//dont has for old user

    // generate a salt callback function for new user using bcrypt.gentSalt()
    bcrypt.genSalt(SALT_WORK_FACTOR, //SALT to get random nubmer 
      function(err, salt) //as soon as SALT generated we have callback function 
      {
        if (err) return next(err);

        // hash the password using our new salt
        console.log("Salt");

          bcrypt.hash(user.password, salt, //calling hash(), it requires SALT number for hash
          //now we have user model instance(plantext.password, salt.randomnubmer)
            function(err, hash) 
            {
              if (err) return next(err);

              // override the cleartext password with the hashed one
              user.password = hash; //plain text into our new hash+salt password
              console.log("Hash : "+hash);
              next();//its successful by not passing err obj. 
            });
      });
}
////callback function end 
);

//helper function which is written on top of methods. we will register func. call comparePassword
//funciton available at model instance level, it can be invoked anywhere using model obj, we will see soon,
//we are regestring on top of methods, methods will be always available 
userSchema.methods.comparePassword = 
function(candidatePassword, cb) { //cb is a callback function cb(), candidatePassword is a parameters 
//it accept candidatePassword to check if password matches at model instance level (save as aboe hook passw)
    bcrypt.compare(candidatePassword, this.password, //if this two (candidatePass = db.pass, match?) 
    //bcrypt has fun call compare()
      function(err, isMatch) {
        if (err) return cb(err);
        cb(null, isMatch); //in callback first parameter is always err object
    });
};

// Build the Login User model Schema, mongooes add name in the colleciton as 'rajusermodels'
mongoose.model( 'RajUserModel', userSchema );//using the schema we are creating a collection call RajUserModel, 
//creating a model is nothing but creating collection in the database. You can fetch the model back 
//by querying the name user directly on object known as mongoose, it is stored with mongoose instance 
//which we have hear. 

// Stories Schema which will be published using summernotes 
var storiesSchema = new mongoose.Schema({
  author:String,
  title: {type: String,unique:true},
  created_at:{type:Date,default:Date.now},
  summary:String,
  content: {type: String},
  imageLink:String,
  comments:[{body:String,commented_by:String,date:Date}],
  slug:String
});
// Build the story model
mongoose.model( 'Story', storiesSchema,'RajCustomStoryName');
